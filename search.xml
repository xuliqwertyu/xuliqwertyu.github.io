<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[xin]]></title>
      <url>%2F2017%2F03%2F02%2F%E6%96%B0%E7%9A%84%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Cookie]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%85%B3%E4%BA%8Ecookie%2F</url>
      <content type="text"><![CDATA[cookie的概念cookie是存储于访问者的计算机中的变量，每当一台计算机通过浏览器请求某个页面得时候，就会发送这个cookie，主要用于保存登陆信息。 cookie的工作原理cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便可获取这个cookie。cookie可以跨越一个域名下面的多个网页，但是不能跨域名也不能跨浏览器。 cookie的缺点 内存太小，大概只有4K cookie可能被禁用，当用户设置安全级别很高时，很可能会禁用浏览器的cookie功能 cookie是与浏览器相关的，不同浏览器之间所保存的cookie不能相互访问 cookie可能被删除，因为每个cookie都是硬盘上的一个文件，有被删除的风险 cookie的安全性不高，所有cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理 设置cookie每个cookie都是一个名称/数值对的形式，将组好的字符串赋值给document.cookiedocument.cookie与其他属性不同，改变它的赋值并不会丢失原来的值在cookie设置的名和值中不能使用分号（;）、逗号（,）、等号（=）以及空格等特殊符号在cookie的名称中很容易做到这点，但是我们要保存的值是不确定的，所以我们需要将值进行编码之后再存储用escape()函数进行编码，将一些特殊符号以及中文转换成十六进制取出值后使用unescape()进行解码 获取cookie通过document.cookie获取到以分号隔开的多个名/值对所组成的字符串通过字符串的切割和截取获取到指定的信息 cookie的生命周期 如果不设置cookie的过期时间，则表示这个cookie生命周期为浏览器的会话周期（当关闭浏览器后，cookie就被销毁了）。这种生命周期为浏览器会话周期的cookie被称为会话cookie，会话cookie一般不保存在硬盘上而是保存在内存里。 如果设置了过期时间，浏览器就会把cookie保存在硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。如何设置过期时间？通过expires设置cookie的过期时间 例如要设置cookie的过期时间为10天 1234var date=new Date(); //获取当前时间var expriesDays=10;date.setTime(date.getTime()+expiresDays*24*3600*1000); //将date设置为10天以后的时间document.cookie=&quot;userid=111;expires=&quot;+date.toGMTString(); //设置cookie过期时间 删除cookie删除一个cookie，可以将其过期时间设置为一个过去的时间123var date =new Date();date.setTime(date.getTime() - 1000);document.cookie = &quot;userid=111; expires=&quot;+date.toGMTString(); 如何将数组和对象存入cookie？因为cookie里面只能存储字符串，所以如果要将数组和对象存入cookie，可以先将其转换成json字符串，再存入cookie JSON.stringify() 取出来之后再将json格式字符串转换成对象 JSON.parse() 实例先创建两个按钮&lt;button id=&quot;btn01&quot;&gt;设置cookie&lt;/button&gt;&lt;button id=&quot;btn02&quot;&gt;删除cookie&lt;/button&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var btn01 = document.getElementById(&quot;btn01&quot;); btn01.onclick = function()&#123; /** * 设置cookie的过期时间 */ //1、获取当前时间 var date =new Date(); var expiresDays = 10; //2、将date设置为10天以后的时间 // date.setTime(date.getTime() + expiresDays*24*3600*1000) //设置1分钟后过期 date.setTime(date.getTime() + 60*1000); //3、设置cookie过期时间 var arr = &#123; name: &quot;张三&quot;, age:20 &#125;; arr = JSON.stringify(arr); document.cookie = &quot;userid=&quot;+arr+&quot;; expires=&quot;+date.toGMTString(); &#125; //删除cookie var btn02 = document.getElementById(&quot;btn02&quot;); btn02.onclick = function()&#123; var date =new Date(); date.setTime(date.getTime() - 1000); document.cookie = &quot;userid=111; expires=&quot;+date.toGMTString(); &#125; //封装一个获取cookie的函数，传入名称，返回它的值 function getCookie(name)&#123; var strCookie = document.cookie; var arrCookie = strCookie.split(&quot;; &quot;); //console.log(arrCookie); for(var i in arrCookie)&#123; var arr = arrCookie[i].split(&quot;=&quot;); //console.log(arr); if(arr[0] == name)&#123; //return 之前进行解码 return unescape(arr[1]); break; &#125; &#125; &#125; var v = getCookie(&quot;userid&quot;); console.log(v);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE兼容性问题]]></title>
      <url>%2F2017%2F02%2F27%2F%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[.box{background:#0066FF!important;background:#FF0000;} 读取前面那个，important具有优先级，但IE6不认.box1{background:#666666;_background:#FF0000} IE6读取后面那个，洽谈读取前面那个_background:#FF0000 只能IE6读取.box1{background:#666666;*background:#FF0000;} IE6+IE7能读取后面那个，其他读取前面那个*background:#FF0000 IE6和IE7都能读取*+html .box3{background:#FF0000} 这个只针对IE7，其他都读取不了*html .box4{background:#FF0000} 这个只针对IE6，其他都读取不了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery选择器]]></title>
      <url>%2F2017%2F02%2F26%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基本选择器标签选择器：$(&quot;p&quot;)类选择器：$(&quot;.intro&quot;)ID选择器：$(&quot;#intro&quot;)， 只能选择一个元素 群组选择器：$(&quot;div, span, p&quot;) 并集，选取所有的DIV SPAN P标签交集选择器：$(&quot;p.p1&quot;) 交集，选取标签名为P并且类名为p1的标签 全局选择器：$(&quot;*&quot;) 全局选择器，选择页面中所有元素 特殊、常用的几个选择器$(document) 选取当前的文档元素$(window) 选取当前页面的窗口对象$(&quot;body&quot;) 选取body元素$(this) 选取当前域的自身对象 标签元素要加双引号，不是标签元素就不要加双引号 层次选择器后代选择器：$(&quot;#box span&quot;)子级选择器：$(&quot;#box&gt;span&quot;)紧邻同辈选择器：$(&quot;#box+p&quot;) 选择#box后面的一个P标签（只能选择一个）相邻同辈选择器：$(&quot;#box~p&quot;) 选择#box后面的所有P标签 属性选择器$(&quot;[name]&quot;) 选择所有包含name属性的标签$(&quot;[name=user]&quot;) 选择所有包含name属性值为user的标签$(&quot;[name!=user]&quot;) 选择所有name属性不等于user的标签，包含了没有name属性的所有标签$(&quot;[name^=user]&quot;) 选择所有name属性以user开头的元素$(&quot;[name$=user]&quot;) 选择所有name属性以user结尾的元素$(&quot;[name][id]&quot;) 选择同时具有name和id属性的元素 过滤选择器:first 选择集合中的第一个元素例:$(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;); :last 选择集合中的最后一个元素例:$(&quot;ul li:last&quot;).css(&quot;color&quot;, &quot;red&quot;); :even 选择集合中的偶数行元素，从0开始，0是偶数例:$(&quot;ul li:even&quot;).css(&quot;color&quot;, &quot;red&quot;); :odd 选择集合中的奇数行元素例:$(&quot;ul li:odd&quot;).css(&quot;color&quot;, &quot;red&quot;); :eq(n) 选择集合中的第n个元素，从0开始例:$(&quot;ul li:eq(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :gt(n) 选择集合中大于n（第n个元素后面的）所有元素例:$(&quot;ul li:gt(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :lt(n) 选择集合中小于n（第n个元素前面的）所有元素例:$(&quot;ul li:lt(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :not(selector) 选择不包含selector的元素例:$(&quot;ul li:not(:eq(3))&quot;).css(&quot;color&quot;, &quot;red&quot;); `$(&quot;ul li:not(.in)&quot;).css(&quot;color&quot;, &quot;red&quot;);` :header 选择所有的h1~h6元素例:$(&quot;div :header&quot;).css(&quot;color&quot;, &quot;red&quot;); :visible 选择所有可见元素例:$(&quot;:visible&quot;).css(&quot;color&quot;, &quot;red&quot;); :hidden 选择所有不可见元素例:$(&quot;:hidden&quot;).css(&quot;color&quot;, &quot;red&quot;); :first-child 选择列表里面的第一个子元素例:$(&quot;dl dd:first-child&quot;).css(&quot;color&quot;, &quot;red&quot;); :last-child 选择列表里面的最后一个子元素例:$(&quot;dl dd:last-child&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-child(n) 选择列表里面的第n个子元素（从1开始）例:$(&quot;dl dd:nth-child(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-last-child(n) 选择列表里面的倒数第n个子元素（从1开始）例:$(&quot;dl dd:nth-last-child(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :first-of-type 选择列表里面匹配类型的第一个元素例:$(&quot;dl dd:first-of-type&quot;).css(&quot;color&quot;, &quot;red&quot;); :last-of-type 选择列表里面匹配类型的最后一个元素例:$(&quot;dl dd:last-of-type&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-of-type(n) 选择列表里面匹配类型的第n个元素（从1开始）例:$(&quot;dl dd:nth-of-type(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-last-of-type(n) 选择列表里面匹配类型的倒数第n个元素（从1开始）例:$(&quot;dl dd:nth-last-of-type(2)&quot;).css(&quot;color&quot;, &quot;red&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery封装的ajax应用]]></title>
      <url>%2F2017%2F02%2F26%2FjQuery_ajax%2F</url>
      <content type="text"><![CDATA[ajax的简易方法：get请求1$.get(url,data,callback,type) url 请求的地址data 需要发送的参数{key:value}callback 请求成功时的回调函数type 指定返回内容的格式(xml、html、script、json、string) 专门加载html文件，并将html代码插入到元素中1$(seletor).load(url) 专门加载script脚本文件1$.getScript(url, callback) 专门加载json数据12$.getJSON(url, callback)$.post(url, data, callback, type) 常用格式12345678$.ajax(&#123; url: url, type: get, data: &#123;&#125;, //要发送到服务器的数据 dataType : //预期服务器返回的数据类型 success : callback //(返回的数据, 返回状态的文字说明, 请求状态信息) error: callback //(请求状态信息，返回状态的文字说明，错误信息说明) &#125;) 例：123456789101112131415161718$.ajax(&#123; type: &quot;post&quot;, url: &quot;php/login.php&quot;, data: &#123;&quot;userName&quot;: &quot;admin&quot;, &quot;passWord&quot;: &quot;123456&quot;&#125;, dataType : &quot;json&quot;, success : function(result)&#123; //result = JSON.parse(result); if(result.status == 200)&#123; //location.href = &quot;index.html&quot;; alert(&quot;成功&quot;); &#125;else&#123; &#125; &#125;, error: function()&#123; alert(&quot;失败&quot;); &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git+nodejs快速搭建web静态服务器]]></title>
      <url>%2F2017%2F02%2F25%2Fnodejs%2F</url>
      <content type="text"><![CDATA[安装nodejs点击可进入官网自行下载进行安装。安装git bash百度自行下载。安装npm:打开git bash 输入以下代码1npm install -g npm --registry=https://registry.npm.taobao.org 安装nvm注意！！！安装以上4个用默认安装路径 以上除了npm和nodejs其他的2个安装包可在以下地址git clone “Web-static-server”文件夹1https://github.com/xuliqwertyu 查看是否安装成功可以在git bash中敲入以下代码：1node -v //检测node是否安装成功，若成功则出现版本号，注意-v之前有空格 1npm -v //检测npm是否安装成功，若成功则出现版本号，注意-v之前有空格 1nvm -v //检测npm是否安装成功，若成功则出现版本号，注意-v之前有空格 开始搭建 在github上clone一个项目文件夹下来 在该文件夹下右击打开git bash Here 输入git config –global user.email’邮箱’ //设置全局git提交邮箱 输入git config –global user.name’用户名’//设置全局git提交用户名 在该文件夹下配置gulpfile.js(名称固定不能更改)文件代码在最底部 配置server.js同上 配置package.json同上 配置.gitignore同上 在该文件夹下创建以下目录 stylus //存放styl文件 public css //存放css文件 img //存放图片 js //存放js文件 views //存放html文件 在该文件夹(clone下来的文件夹)下打开git bash输入npm install若成功则会出现node_modules文件夹 在git bash 中输入npm insall express –save 在git bash 中输入npm install gulp -g 在git bash 中输入npm install gulp –save-dev 在git bash 中输入npm install nrm -g 至此web静态服务器搭建完成，只要在该项目文件夹根目录打开git bash 输入gulp watcher启动静态服务器，再在浏览器输入localhost:9999即可。将9999改为9888为实时更新。 gulpfile.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//引入gulpvar gulp=require(&apos;gulp&apos;);//引入gulp-stylus插件var stylus=require(&apos;gulp-stylus&apos;)//创建一个编译stylus的任务gulp.task(&apos;stylus&apos;,function()&#123;//获取要编译的文件//指定一个文件//gulp.src(&apos;./stylus/index.styl&apos;)//指定多个文件//gulp.src([&apos;./stylus/index.styl&apos;,&apos;./stylus/css.styl&apos;])//指定一个目录下所有(不包含子目录)//gulp.src(&apos;./stylus/*.styl&apos;)//指定一个目录及所有子目录下的文件return gulp.src(&apos;./stylus/**/*.styl&apos;) //执行stylus编译 .pipe(stylus()) //输出编译后的文件 .pipe(gulp.dest(&apos;./public/css&apos;))&#125;)//创建一个default任务gulp.task(&apos;logs&apos;,function()&#123;console.log(&apos;this is log&apos;)&#125;)gulp.task(&apos;default&apos;,function()&#123;console.log(&apos;this default&apos;)&#125;);gulp.task(&apos;es6&apos;,function()&#123;console.log(&apos;this es6&apos;)&#125;);gulp.task(&apos;css&apos;,function()&#123;console.log(&apos;this css&apos;)&#125;);gulp.task(&apos;all&apos;,[&apos;logs&apos;,&apos;es6&apos;,&apos;css&apos;],function()&#123;console.log(&apos;this is all&apos;)&#125;);gulp.task(&apos;minijs&apos;,[&apos;es6&apos;],function()&#123;console.log(&apos;this is minijs&apos;)&#125;) //先执行es6，后执行minijs//var minifycss=require(&apos;gulp-minify-css&apos;)gulp.task(&apos;minifycss&apos;,[&apos;stylus&apos;],function()&#123;return gulp.src(&apos;./public/css/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public/mincss&apos;))&#125;)var uglify=require(&apos;gulp-uglify&apos;)gulp.task(&apos;uglify&apos;,function()&#123;return gulp.src(&apos;./public/js/**/*.js&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public/minjs&apos;))&#125;)gulp.task(&apos;watcher&apos;,[&apos;stylus&apos;, &apos;browserSync&apos;],function()&#123; gulp.watch(&apos;./public/js/**/*.js&apos;,[&apos;uglify&apos;]); gulp.watch(&apos;./stylus/**/*.styl&apos;,[&apos;stylus&apos;]); gulp.watch([ &apos;./public/css/**/*.css&apos;, &apos;./public/minjs/**/*.js&apos; ]).on(&apos;change&apos;,function()&#123; reload(); &#125;)&#125;)var nodemon=require(&apos;gulp-nodemon&apos;)gulp.task(&apos;nodemon&apos;,function(ab)&#123;var ft=false;return nodemon(&#123;script:&apos;./server.js&apos;&#125;).on(&apos;start&apos;,function()&#123; if(!ft)&#123; ab(); ft=true; &#125;&#125;)&#125;)var browserSync=require(&apos;browser-sync&apos;).create()var reload=browserSync.reloadgulp.task(&apos;browserSync&apos;,[&apos;nodemon&apos;],function()&#123; browserSync.init(&#123; proxy:&#123; target:&apos;http://127.0.0.1:9999&apos; &#125;, files:[&apos;*&apos;], port:9888, open:false &#125;)&#125;) package.json12345678910111213141516171819202122232425262728&#123; &quot;name&quot;: &quot;my-c&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://code.aliyun.com/walkingin/CyyAPP.git&quot; &#125;, &quot;author&quot;: &quot;xl&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.14.0&quot;, &quot;sha1&quot;: &quot;^1.1.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.18.5&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-browser-sync&quot;: &quot;0.0.4&quot;, &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, &quot;gulp-nodemon&quot;: &quot;^2.2.1&quot;, &quot;gulp-stylus&quot;: &quot;^2.6.0&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot; &#125; &#125; server.js12345678910111213141516171819202122232425262728293031323334353637var path =require(&apos;path&apos;); var express =require(&apos;express&apos;); var app=express(); var viewsPath=path.join(__dirname,&apos;views&apos;); app.use(&apos;/&apos;,express.static(viewsPath)); var publicPath=path.join(__dirname,&apos;public&apos;); app.use(&apos;/public&apos;,express.static(publicPath)); app.listen(9999,function()&#123; console.log(&apos;server run at port 9999&apos;); &#125;) var sha1 = require(&quot;sha1&quot;); //定义验证接口 app.use(&apos;/wexin&apos;, function(req, res)&#123; //获取get传递数据 var obj = req.query; console.log(&quot;weixin&quot;, obj); //将数据添加到一个数组 var arr = [&quot;tasktest&quot;, obj.timestamp, obj.nonce]; //排序 arr.sort(); //拼接字符串，并进行 sha1 加密 var str = sha1(arr.join(&quot;&quot;)); console.log(&apos;sha1 &apos;, str); console.log(&apos;signature&apos;, obj.signature === str) //匹配是否是微信请求 if( obj.signature === str)&#123; //成功返回 echostr 随机字符串 res.send(obj.echostr).end(); &#125;else&#123; res.send(&quot;验证失败&quot;).end(); &#125; &#125;); module.exports=app; 以上配置文件在以下地址中的“Web-static-server”文件夹都有1https://github.com/xuliqwertyu]]></content>
    </entry>

    
  
  
</search>

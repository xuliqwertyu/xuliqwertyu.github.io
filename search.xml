<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[关于Cookie]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%85%B3%E4%BA%8Ecookie%2F</url>
      <content type="text"><![CDATA[cookie的概念cookie是存储于访问者的计算机中的变量，每当一台计算机通过浏览器请求某个页面得时候，就会发送这个cookie，主要用于保存登陆信息。 cookie的工作原理cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便可获取这个cookie。cookie可以跨越一个域名下面的多个网页，但是不能跨域名也不能跨浏览器。 cookie的缺点 内存太小，大概只有4K cookie可能被禁用，当用户设置安全级别很高时，很可能会禁用浏览器的cookie功能 cookie是与浏览器相关的，不同浏览器之间所保存的cookie不能相互访问 cookie可能被删除，因为每个cookie都是硬盘上的一个文件，有被删除的风险 cookie的安全性不高，所有cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理 设置cookie每个cookie都是一个名称/数值对的形式，将组好的字符串赋值给document.cookiedocument.cookie与其他属性不同，改变它的赋值并不会丢失原来的值在cookie设置的名和值中不能使用分号（;）、逗号（,）、等号（=）以及空格等特殊符号在cookie的名称中很容易做到这点，但是我们要保存的值是不确定的，所以我们需要将值进行编码之后再存储用escape()函数进行编码，将一些特殊符号以及中文转换成十六进制取出值后使用unescape()进行解码 获取cookie通过document.cookie获取到以分号隔开的多个名/值对所组成的字符串通过字符串的切割和截取获取到指定的信息 cookie的生命周期 如果不设置cookie的过期时间，则表示这个cookie生命周期为浏览器的会话周期（当关闭浏览器后，cookie就被销毁了）。这种生命周期为浏览器会话周期的cookie被称为会话cookie，会话cookie一般不保存在硬盘上而是保存在内存里。 如果设置了过期时间，浏览器就会把cookie保存在硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。如何设置过期时间？通过expires设置cookie的过期时间 例如要设置cookie的过期时间为10天 1234var date=new Date(); //获取当前时间var expriesDays=10;date.setTime(date.getTime()+expiresDays*24*3600*1000); //将date设置为10天以后的时间document.cookie="userid=111;expires="+date.toGMTString(); //设置cookie过期时间 删除cookie删除一个cookie，可以将其过期时间设置为一个过去的时间123var date =new Date();date.setTime(date.getTime() - 1000);document.cookie = "userid=111; expires="+date.toGMTString(); 如何将数组和对象存入cookie？因为cookie里面只能存储字符串，所以如果要将数组和对象存入cookie，可以先将其转换成json字符串，再存入cookie JSON.stringify() 取出来之后再将json格式字符串转换成对象 JSON.parse() 实例先创建两个按钮&lt;button id=&quot;btn01&quot;&gt;设置cookie&lt;/button&gt;&lt;button id=&quot;btn02&quot;&gt;删除cookie&lt;/button&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var btn01 = document.getElementById("btn01"); btn01.onclick = function()&#123; /** * 设置cookie的过期时间 */ //1、获取当前时间 var date =new Date(); var expiresDays = 10; //2、将date设置为10天以后的时间 // date.setTime(date.getTime() + expiresDays*24*3600*1000) //设置1分钟后过期 date.setTime(date.getTime() + 60*1000); //3、设置cookie过期时间 var arr = &#123; name: "张三", age:20 &#125;; arr = JSON.stringify(arr); document.cookie = "userid="+arr+"; expires="+date.toGMTString(); &#125; //删除cookie var btn02 = document.getElementById("btn02"); btn02.onclick = function()&#123; var date =new Date(); date.setTime(date.getTime() - 1000); document.cookie = "userid=111; expires="+date.toGMTString(); &#125; //封装一个获取cookie的函数，传入名称，返回它的值 function getCookie(name)&#123; var strCookie = document.cookie; var arrCookie = strCookie.split("; "); //console.log(arrCookie); for(var i in arrCookie)&#123; var arr = arrCookie[i].split("="); //console.log(arr); if(arr[0] == name)&#123; //return 之前进行解码 return unescape(arr[1]); break; &#125; &#125; &#125; var v = getCookie("userid"); console.log(v);]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F02%2F27%2F%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[title: IE兼容性问题 tags: [兼容性，IE].box{background:#0066FF!important;background:#FF0000;} 读取前面那个，important具有优先级，但IE6不认.box1{background:#666666;_background:#FF0000} IE6读取后面那个，洽谈读取前面那个_background:#FF0000 只能IE6读取.box1{background:#666666;*background:#FF0000;} IE6+IE7能读取后面那个，其他读取前面那个*background:#FF0000 IE6和IE7都能读取*+html .box3{background:#FF0000} 这个只针对IE7，其他都读取不了*html .box4{background:#FF0000} 这个只针对IE6，其他都读取不了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery选择器]]></title>
      <url>%2F2017%2F02%2F26%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基本选择器标签选择器：$(&quot;p&quot;)类选择器：$(&quot;.intro&quot;)ID选择器：$(&quot;#intro&quot;)， 只能选择一个元素 群组选择器：$(&quot;div, span, p&quot;) 并集，选取所有的DIV SPAN P标签交集选择器：$(&quot;p.p1&quot;) 交集，选取标签名为P并且类名为p1的标签 全局选择器：$(&quot;*&quot;) 全局选择器，选择页面中所有元素 特殊、常用的几个选择器$(document) 选取当前的文档元素$(window) 选取当前页面的窗口对象$(&quot;body&quot;) 选取body元素$(this) 选取当前域的自身对象 标签元素要加双引号，不是标签元素就不要加双引号 层次选择器后代选择器：$(&quot;#box span&quot;)子级选择器：$(&quot;#box&gt;span&quot;)紧邻同辈选择器：$(&quot;#box+p&quot;) 选择#box后面的一个P标签（只能选择一个）相邻同辈选择器：$(&quot;#box~p&quot;) 选择#box后面的所有P标签 属性选择器$(&quot;[name]&quot;) 选择所有包含name属性的标签$(&quot;[name=user]&quot;) 选择所有包含name属性值为user的标签$(&quot;[name!=user]&quot;) 选择所有name属性不等于user的标签，包含了没有name属性的所有标签$(&quot;[name^=user]&quot;) 选择所有name属性以user开头的元素$(&quot;[name$=user]&quot;) 选择所有name属性以user结尾的元素$(&quot;[name][id]&quot;) 选择同时具有name和id属性的元素 过滤选择器:first 选择集合中的第一个元素例:$(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;); :last 选择集合中的最后一个元素例:$(&quot;ul li:last&quot;).css(&quot;color&quot;, &quot;red&quot;); :even 选择集合中的偶数行元素，从0开始，0是偶数例:$(&quot;ul li:even&quot;).css(&quot;color&quot;, &quot;red&quot;); :odd 选择集合中的奇数行元素例:$(&quot;ul li:odd&quot;).css(&quot;color&quot;, &quot;red&quot;); :eq(n) 选择集合中的第n个元素，从0开始例:$(&quot;ul li:eq(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :gt(n) 选择集合中大于n（第n个元素后面的）所有元素例:$(&quot;ul li:gt(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :lt(n) 选择集合中小于n（第n个元素前面的）所有元素例:$(&quot;ul li:lt(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :not(selector) 选择不包含selector的元素例:$(&quot;ul li:not(:eq(3))&quot;).css(&quot;color&quot;, &quot;red&quot;); `$(&quot;ul li:not(.in)&quot;).css(&quot;color&quot;, &quot;red&quot;);` :header 选择所有的h1~h6元素例:$(&quot;div :header&quot;).css(&quot;color&quot;, &quot;red&quot;); :visible 选择所有可见元素例:$(&quot;:visible&quot;).css(&quot;color&quot;, &quot;red&quot;); :hidden 选择所有不可见元素例:$(&quot;:hidden&quot;).css(&quot;color&quot;, &quot;red&quot;); :first-child 选择列表里面的第一个子元素例:$(&quot;dl dd:first-child&quot;).css(&quot;color&quot;, &quot;red&quot;); :last-child 选择列表里面的最后一个子元素例:$(&quot;dl dd:last-child&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-child(n) 选择列表里面的第n个子元素（从1开始）例:$(&quot;dl dd:nth-child(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-last-child(n) 选择列表里面的倒数第n个子元素（从1开始）例:$(&quot;dl dd:nth-last-child(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :first-of-type 选择列表里面匹配类型的第一个元素例:$(&quot;dl dd:first-of-type&quot;).css(&quot;color&quot;, &quot;red&quot;); :last-of-type 选择列表里面匹配类型的最后一个元素例:$(&quot;dl dd:last-of-type&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-of-type(n) 选择列表里面匹配类型的第n个元素（从1开始）例:$(&quot;dl dd:nth-of-type(3)&quot;).css(&quot;color&quot;, &quot;red&quot;); :nth-last-of-type(n) 选择列表里面匹配类型的倒数第n个元素（从1开始）例:$(&quot;dl dd:nth-last-of-type(2)&quot;).css(&quot;color&quot;, &quot;red&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery封装的ajax应用]]></title>
      <url>%2F2017%2F02%2F26%2FjQuery_ajax%2F</url>
      <content type="text"><![CDATA[ajax的简易方法：get请求1$.get(url,data,callback,type) url 请求的地址data 需要发送的参数{key:value}callback 请求成功时的回调函数type 指定返回内容的格式(xml、html、script、json、string) 专门加载html文件，并将html代码插入到元素中1$(seletor).load(url) 专门加载script脚本文件1$.getScript(url, callback) 专门加载json数据12$.getJSON(url, callback)$.post(url, data, callback, type) 常用格式12345678$.ajax(&#123; url: url, type: get, data: &#123;&#125;, //要发送到服务器的数据 dataType : //预期服务器返回的数据类型 success : callback //(返回的数据, 返回状态的文字说明, 请求状态信息) error: callback //(请求状态信息，返回状态的文字说明，错误信息说明) &#125;) 例：123456789101112131415161718$.ajax(&#123; type: "post", url: "php/login.php", data: &#123;"userName": "admin", "passWord": "123456"&#125;, dataType : "json", success : function(result)&#123; //result = JSON.parse(result); if(result.status == 200)&#123; //location.href = "index.html"; alert("成功"); &#125;else&#123; &#125; &#125;, error: function()&#123; alert("失败"); &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git+nodejs快速搭建web静态服务器]]></title>
      <url>%2F2017%2F02%2F25%2Fnodejs%2F</url>
      <content type="text"><![CDATA[安装nodejs点击可进入官网自行下载进行安装。安装git bash百度自行下载。安装npm:打开git bash 输入以下代码1npm install -g npm --registry=https://registry.npm.taobao.org 安装nvm注意！！！安装以上4个用默认安装路径 以上除了npm和nodejs其他的2个安装包可在以下地址git clone “Web-static-server”文件夹1https://github.com/xuliqwertyu 查看是否安装成功可以在git bash中敲入以下代码：1node -v //检测node是否安装成功，若成功则出现版本号，注意-v之前有空格 1npm -v //检测npm是否安装成功，若成功则出现版本号，注意-v之前有空格 1nvm -v //检测npm是否安装成功，若成功则出现版本号，注意-v之前有空格 开始搭建 在github上clone一个项目文件夹下来 在该文件夹下右击打开git bash Here 输入git config –global user.email’邮箱’ //设置全局git提交邮箱 输入git config –global user.name’用户名’//设置全局git提交用户名 在该文件夹下配置gulpfile.js(名称固定不能更改)文件代码在最底部 配置server.js同上 配置package.json同上 配置.gitignore同上 在该文件夹下创建以下目录 stylus //存放styl文件 public css //存放css文件 img //存放图片 js //存放js文件 views //存放html文件 在该文件夹(clone下来的文件夹)下打开git bash输入npm install若成功则会出现node_modules文件夹 在git bash 中输入npm insall express –save 在git bash 中输入npm install gulp -g 在git bash 中输入npm install gulp –save-dev 在git bash 中输入npm install nrm -g 至此web静态服务器搭建完成，只要在该项目文件夹根目录打开git bash 输入gulp watcher启动静态服务器，再在浏览器输入localhost:9999即可。将9999改为9888为实时更新。 gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//引入gulpvar gulp=require('gulp');//引入gulp-stylus插件var stylus=require('gulp-stylus')//创建一个编译stylus的任务gulp.task('stylus',function()&#123;//获取要编译的文件//指定一个文件//gulp.src('./stylus/index.styl')//指定多个文件//gulp.src(['./stylus/index.styl','./stylus/css.styl'])//指定一个目录下所有(不包含子目录)//gulp.src('./stylus/*.styl')//指定一个目录及所有子目录下的文件return gulp.src('./stylus/**/*.styl') //执行stylus编译 .pipe(stylus()) //输出编译后的文件 .pipe(gulp.dest('./public/css'))&#125;)//创建一个default任务gulp.task('logs',function()&#123;console.log('this is log')&#125;)gulp.task('default',function()&#123;console.log('this default')&#125;);gulp.task('es6',function()&#123;console.log('this es6')&#125;);gulp.task('css',function()&#123;console.log('this css')&#125;);gulp.task('all',['logs','es6','css'],function()&#123;console.log('this is all')&#125;);gulp.task('minijs',['es6'],function()&#123;console.log('this is minijs')&#125;) //先执行es6，后执行minijs//var minifycss=require('gulp-minify-css')gulp.task('minifycss',['stylus'],function()&#123;return gulp.src('./public/css/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public/mincss'))&#125;)var uglify=require('gulp-uglify')gulp.task('uglify',function()&#123;return gulp.src('./public/js/**/*.js') .pipe(minifycss()) .pipe(gulp.dest('./public/minjs'))&#125;)gulp.task('watcher',['stylus', 'browserSync'],function()&#123; gulp.watch('./public/js/**/*.js',['uglify']); gulp.watch('./stylus/**/*.styl',['stylus']); gulp.watch([ './public/css/**/*.css', './public/minjs/**/*.js' ]).on('change',function()&#123; reload(); &#125;)&#125;)var nodemon=require('gulp-nodemon')gulp.task('nodemon',function(ab)&#123;var ft=false;return nodemon(&#123;script:'./server.js'&#125;).on('start',function()&#123; if(!ft)&#123; ab(); ft=true; &#125;&#125;)&#125;)var browserSync=require('browser-sync').create()var reload=browserSync.reloadgulp.task('browserSync',['nodemon'],function()&#123; browserSync.init(&#123; proxy:&#123; target:'http://127.0.0.1:9999' &#125;, files:['*'], port:9888, open:false &#125;)&#125;) package.json12345678910111213141516171819202122232425262728&#123; "name": "my-c", "version": "0.0.1", "description": "", "main": "app.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "https://code.aliyun.com/walkingin/CyyAPP.git" &#125;, "author": "xl", "license": "ISC", "dependencies": &#123; "express": "^4.14.0", "sha1": "^1.1.1" &#125;, "devDependencies": &#123; "browser-sync": "^2.18.5", "gulp": "^3.9.1", "gulp-browser-sync": "0.0.4", "gulp-minify-css": "^1.2.4", "gulp-nodemon": "^2.2.1", "gulp-stylus": "^2.6.0", "gulp-uglify": "^2.0.0" &#125; &#125; server.js12345678910111213141516171819202122232425262728293031323334353637var path =require('path'); var express =require('express'); var app=express(); var viewsPath=path.join(__dirname,'views'); app.use('/',express.static(viewsPath)); var publicPath=path.join(__dirname,'public'); app.use('/public',express.static(publicPath)); app.listen(9999,function()&#123; console.log('server run at port 9999'); &#125;) var sha1 = require("sha1"); //定义验证接口 app.use('/wexin', function(req, res)&#123; //获取get传递数据 var obj = req.query; console.log("weixin", obj); //将数据添加到一个数组 var arr = ["tasktest", obj.timestamp, obj.nonce]; //排序 arr.sort(); //拼接字符串，并进行 sha1 加密 var str = sha1(arr.join("")); console.log('sha1 ', str); console.log('signature', obj.signature === str) //匹配是否是微信请求 if( obj.signature === str)&#123; //成功返回 echostr 随机字符串 res.send(obj.echostr).end(); &#125;else&#123; res.send("验证失败").end(); &#125; &#125;); module.exports=app; 以上配置文件在以下地址中的“Web-static-server”文件夹都有1https://github.com/xuliqwertyu]]></content>
    </entry>

    
  
  
</search>
